\section{Медленные сортировки}

\subsection{Устойчивость сортировки}

Сохранение порядка равных элементов

\subsection{Варианты сортировок}

$$\begin{array}{c|c|c|c|c}
    \text{Название} & \text{Сложность} & \text{Память} & \text{Присваивания} & \text{Устойчивость} \\
    \hline
    \text{Сортировка пузырьком} & O(n^2) & O(1) & O(n^2) & 1 \\
    \text{Сортировка выбором} & O(n^2) & O(1) & O(n) & 0 \\
    \text{Сортировка вставкой} & O(n^2) & O(1) & O(n^2) & 1 \\
\end{array}$$


\section{Быстрые сортировки}

\subsection{Оценка времени снизу}

Исходя из принципа количества информации, с помощью бинарных вопросов можно угадать обратную перестановку не быстрее, чем за $O(n\log n) \sim O(n!)$

\subsection{Сортировка слиянием}

$$\begin{array}{c|c|c|c|c}
    \text{Название} & \text{Сложность} & \text{Память} & \text{Присваивания} & \text{Устойчивость} \\
    \hline
    \text{Сортировка слиянием} & O(n \log n) & O(n) & O(n \log n) & 1
\end{array}$$

\begin{enumerate}
    \item Функция $merge(seq1, seq2)$
    \item Вызываем рекурсивно, разделяя массив пополам, вплоть до очевидного случая
    \item Когда мы проваливаемся на самый низкий уровень сравнения, то потребляется $\log n$
    \item У рекурсивных вызовов большая константа
\end{enumerate}

\subsection{Подсчет количества инверсий}

\begin{enumerate}
    \item Сортируем массив
    \item Считаем разницу в индексах и однозначно определяем количесвто инверсий с этим элементом
\end{enumerate}


\subsection{Сортировка кучей (HeapSort)}

$$\begin{array}{c|c|c|c|c}
    \text{Название} & \text{Сложность} & \text{Память} & \text{Присваивания} & \text{Устойчивость} \\
    \hline
    \text{Быстрая сортировка} & O(n \log n) & O(\log n) & - & 0
\end{array}$$


\subsection{Быстрая сортировка}

$$\begin{array}{c|c|c|c|c}
    \text{Название} & \text{Сложность} & \text{Память} & \text{Присваивания} & \text{Устойчивость} \\
    \hline
    \text{Быстрая сортировка} & O(n \log n) & O(\log n) & - & 0
\end{array}$$

\begin{enumerate}
    \item Выбираем случайный элемент
    \item Разбиваем массив на 3 части \begin{enumerate}
        \item меньше $x$
        \item больше $x$
        \item равно $x$
    \end{enumerate}
    \item Рекурсивно вызываем функцию в меньшей части, а в основной, в случае задачи оптимизации памяти, продолжаем работать в том же вызове функции
    \item Худший случай - $O(n^2)$
\end{enumerate}

\subsection{Задача о поиске k-ой статистики}

$$\begin{array}{c|c|c|c}
    \text{Название} & \text{Сложность} & \text{Память} & \text{Присваивания} \\
    \hline
    \text{Задача} & O(n) & O(1) & -
\end{array}$$

\begin{enumerate}
    \item Запускаем $partision$
    \item Получаем 2 части, выбираем нужную
    \item Работаем в одном вызове функции
\end{enumerate}


\subsection{Сортировка подсчетом}

$$\begin{array}{c|c|c|c|c}
    \text{Название} & \text{Сложность} & \text{Память} & \text{Присваивания} & \text{Устойчивость} \\
    \hline
    \text{Сортировка подсчетом} & O(n + k) & O(k) & - & 0 / 1
\end{array}$$

\begin{enumerate}
    \item Находим минимальный и максимальный элемент ($k$ возможных значений)
    \item Создаем, содержащий все возможные элементы
\end{enumerate}


\subsection{Сортировка по разрядам}

$$\begin{array}{c|c|c|c|c}
    \text{Название} & \text{Сложность} & \text{Память} & \text{Присваивания} & \text{Устойчивость} \\
    \hline
    \text{Сортировка по разрядам} & O\big((n + k) \cdot p\big) & O(k) & - & 1
\end{array}$$

\begin{enumerate}
    \item Применяем устойчивую версию сортировки подсчетом для каждого $p$ разряда (которые состоят из $k$ штук)
    \item Очень сложно писать
\end{enumerate}


\section{Динамическое программирование - 1}

\subsection{Примеры задач}

\begin{enumerate}
    \item Задача о ступеньках (в том числе с запрещенными ступеньками)
    \item Задача о поиске $n$ - го числа фиббоначи
    \item Задача о минимизации затрат
    \item Задача о столбац и сварщике (нельзя выпиливать 2 столба подряд)
    \item Задача о наибольшей возрастающей подпоследовательности
    \item Задача о поиске наибольшей общей подпоследовательности в строках
    \item Поиск кратчайшего представления числа
\end{enumerate}


\subsection{Инструменты}

\begin{enumerate}
    \item Добавление фиктивных элементов
    \item Внедрение матриц при вычислении реккурентно-заданных последовательностей
    \item Придумывать смысл формулы
\end{enumerate}


\subsection{Способы восстановления сертификата}

\begin{enumerate}
    \item В динамике определяем нужный вариант проходя в обратную сторону
    \item Используем дополнительную память
\end{enumerate}


\subsection{Задача о поиске наибольшей общей подпоследовательности в строках (строим таблицу)}

Строим таблицу, где каждая ячейка отображает длину подстроки на данный момент


\subsection{Поиск кратчайшего представления числа}

Находим оптимальную по длине запись слагаемого $k < n$ и представляем как сумму или произведение


\section{Динамическое программирование - 2}

\subsection{Задача о обеде в столовой}

\subsubsection{Условие:}

\begin{enumerate}
    \item Поесть можно либо за деньги, либо за купон, который выдается за дорогой обед 
    \item Нужно минимизировать затраты
\end{enumerate}

\subsubsection{Решение:}

\begin{enumerate}
    \item Ввод дополнительного параметра, строим таблицу вместо строки
    \item $dp[i][j]$ - количесвто купонов в $i$ день с сегодняшней ценой обеда $j$
    $$dp[i][j] = \min\left\{\begin{matrix}
        dp[i - 1][j + 1] & \\\\
        dp[i - 1][j - 1] + a_i & \text{если $a_i \geq 1000$} \\\\
        dp[i - 1][j] + a_i & \text{иначе}
    \end{matrix}\right\}$$
\end{enumerate}


\subsection{Задача о покупке ткани}

\subsubsection{Условие:}

\begin{enumerate}
    \item $T$ - требуемый размер ткани, $N$ - количество магазинов
    \item $a_i$ - цена, $b_i$ - оптовый барьер
    \item $c_i$ - оптовая цена, $d_i$ - всего метров
\end{enumerate}

\subsubsection{Решение:}

\begin{enumerate}
    \item Пишем функцию $f$, которая возвращает минимальные затраты на покупку $x$ метров ткани
    \item Решить для 2-х магазинов
    \item Решить для (1, 2) - го и 3 - го магазина
    \item Продолжить для следующих
    \item $dp[i][j]$ - затраты, первая группа магазинов $i$, второй магазин $j$
    $$dp[i][j] = \min_{0, \dots, j}\left\{dp[i - 1][k] + f(i, j - k)\right\}$$ 
\end{enumerate}


\subsection{Задача о елках}

\subsubsection{Условие:}

\begin{enumerate}
    \item $N, T$ - количество елок и клу
    \item $w_i, e_i$ - отбрасываемая тень $i$ - ой елки
    \item Елку нельзя сажать, если на нее отбрасывается тень
    \item Максимизировать количество елок
\end{enumerate}

\subsubsection{Решение:}

\begin{enumerate}
    \item $dp[i][j]$ - минимальная тень на восток (последний посаженный сорт), где последняя занятая клетка -$i$, $j$ - количество елок\end{enumerate}
\end{document}